
this is variant of lis jb bhi condition ho or subsequence puch toh lis soch in this case i just calculate the remainder then run a loop and find the maximum subsequence for each remainder

class Solution {
public:
    int solve(vector<int>& nums, int prev, int i, int k, int n, int val, vector<vector<int>>& dp) {
        if (i >= n) return 0;
        if (dp[i][prev + 1] != -1) return dp[i][prev + 1];

        int take = 0;
        if (prev == -1 || (nums[prev] + nums[i]) % k == val) {
            take = 1 + solve(nums, i, i + 1, k, n, val, dp);
        }

        int not_take = solve(nums, prev, i + 1, k, n, val, dp);
        return dp[i][prev + 1] = max(take, not_take);
    }

    int maximumLength(vector<int>& nums, int k) {
        int n = nums.size();
        int maxi = 0;

        if (n > 1000) n = 1000;

        for (int val = 0; val < k; val++) {
            vector<vector<int>> dp(n, vector<int>(n + 1, -1));
            maxi = max(maxi, solve(nums, -1, 0, k, n, val, dp));
        }

        return maxi;
    }
};
